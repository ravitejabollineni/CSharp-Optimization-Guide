# 283. Move Zeroes

## Problem Statement

Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Note:** You must do this **in-place** without making a copy of the array.

---

## Examples

### Example 1:
```
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
```

### Example 2:
```
Input: nums = [0]
Output: [0]
```

---

## Constraints

* `1 <= nums.length <= 10^4`
* `-2^31 <= nums[i] <= 2^31 - 1`

---

## Follow-up

Could you minimize the total number of operations done?

---

## Solution

### Approach: Two Pointers with Optimized Swap

This solution uses the **two-pointer technique** with an optimization to minimize operations.

```csharp
public class Solution {
    public void MoveZeroes(int[] nums) {
        int left = 0;
        for(int right = 0; right < nums.Length; right++)
        {
            if(nums[right] != 0)
            {
                if(left != right)
                {
                    int temp = nums[left];
                    nums[left] = nums[right];
                    nums[right] = temp;
                }
                left++;
            }
        }
    }
}
```

---

## Algorithm Explanation

### Core Concept

The algorithm uses two pointers:
- **`left`**: Points to the position where the next non-zero element should be placed
- **`right`**: Scans through the entire array

### Step-by-Step Process

1. **Initialize** `left` pointer at index 0
2. **Iterate** through array with `right` pointer from 0 to n-1
3. **When a non-zero element is found** at `right`:
   - If `left != right`: Swap `nums[left]` and `nums[right]`
   - Move `left` pointer forward
4. **When a zero is found**: Only `right` moves forward (skip it)

### Visual Walkthrough

Let's trace through Example 1: `nums = [0,1,0,3,12]`

```
Initial State:
Array: [0, 1, 0, 3, 12]
        ↑
     L,R

Step 1: right=0, nums[0]=0 (zero, skip)
Array: [0, 1, 0, 3, 12]
        ↑  ↑
        L  R

Step 2: right=1, nums[1]=1 (non-zero, left≠right, swap)
Array: [1, 0, 0, 3, 12]
           ↑  ↑
           L  R
left moves to 1

Step 3: right=2, nums[2]=0 (zero, skip)
Array: [1, 0, 0, 3, 12]
           ↑     ↑
           L     R

Step 4: right=3, nums[3]=3 (non-zero, left≠right, swap)
Array: [1, 3, 0, 0, 12]
              ↑     ↑
              L     R
left moves to 2

Step 5: right=4, nums[4]=12 (non-zero, left≠right, swap)
Array: [1, 3, 12, 0, 0]
                 ↑     ↑
                 L     R
left moves to 3

Result: [1, 3, 12, 0, 0] ✓
```

---

## Key Optimization

### The `if(left != right)` Check

This is the **critical optimization** that addresses the follow-up question!

**Why is this important?**

When `left == right`, it means:
- We haven't encountered any zeros yet, OR
- The current element is already in its correct position

In both cases, **swapping would be unnecessary** because we'd be swapping an element with itself.

### Example of Optimization in Action

```
Array: [1, 2, 3, 0, 0]
        ↑
       L,R

Since left == right and nums[0] = 1 (non-zero):
- No swap needed! (would swap 1 with itself)
- Just move left forward

This saves unnecessary operations!
```

---

## Complexity Analysis

### Time Complexity: **O(n)**
- Single pass through the array
- Each element is visited exactly once
- `n` = length of the array

### Space Complexity: **O(1)**
- Only uses two pointer variables (`left` and `right`)
- In-place algorithm, no extra data structures
- Satisfies the in-place requirement

### Operation Count
- **Worst case**: When all elements are non-zero and in reverse order
  - Swaps: O(n)
- **Best case**: When array is already sorted or has no zeros
  - Swaps: 0 (thanks to the `left != right` optimization!)
- **Average case**: Approximately O(k) swaps, where k is the number of zeros

---

## Why This Solution is Optimal

### Advantages

1. ✅ **Single Pass**: Only one iteration through the array
2. ✅ **In-Place**: No extra space required (O(1) space)
3. ✅ **Minimized Operations**: The `left != right` check avoids unnecessary swaps
4. ✅ **Stable**: Maintains relative order of non-zero elements
5. ✅ **Simple**: Easy to understand and implement

### Comparison with Other Approaches

| Approach | Time | Space | Operations | Readability |
|----------|------|-------|------------|-------------|
| Two-Pass (Copy non-zeros, then fill zeros) | O(n) | O(1) | ~n writes | High |
| **Optimized Swap (This solution)** | **O(n)** | **O(1)** | **Minimal swaps** | **High** |
| Bubble-style | O(n²) | O(1) | Many swaps | Low |

---

## Edge Cases Handled

1. **Single element array**: `[0]` → `[0]` ✓
2. **All zeros**: `[0,0,0]` → `[0,0,0]` ✓
3. **No zeros**: `[1,2,3]` → `[1,2,3]` ✓ (no swaps due to optimization)
4. **Zeros at beginning**: `[0,0,1,2]` → `[1,2,0,0]` ✓
5. **Zeros at end**: `[1,2,0,0]` → `[1,2,0,0]` ✓ (no swaps needed)
6. **Alternating**: `[1,0,2,0,3]` → `[1,2,3,0,0]` ✓

---

## Common Mistakes to Avoid

1. ❌ **Forgetting to move `left` forward**: Only increment when non-zero is found
2. ❌ **Not checking `left != right`**: Results in unnecessary self-swaps
3. ❌ **Creating new array**: Violates the in-place requirement
4. ❌ **Using extra space for counting**: Not needed with two pointers

---

## Interview Tips

### What to Mention

- "I'll use two pointers to solve this in-place"
- "The left pointer tracks where non-zeros should go"
- "I'll optimize by avoiding unnecessary swaps when left equals right"
- "This achieves O(n) time and O(1) space"

### Follow-up Answer

**Q: Can you minimize operations?**

**A:** "Yes! The key is the `if(left != right)` check before swapping. This prevents unnecessary operations when:
1. No zeros have been encountered yet (left == right)
2. The element is already in the correct position

This reduces the average number of swaps significantly."

---

## Related Problems

- **283. Move Zeroes** (This problem)
- **27. Remove Element**
- **26. Remove Duplicates from Sorted Array**
- **75. Sort Colors** (Dutch National Flag)
- **88. Merge Sorted Array**

All use similar two-pointer techniques!

---

## Practice Variations

Try solving these variations to master the concept:

1. Move all zeros to the **beginning** instead
2. Move all **negative numbers** to the end
3. Move all **even numbers** to the beginning
4. **Count** the number of swaps made

---

## Summary

This solution elegantly solves the Move Zeroes problem using:
- **Two pointers** for efficient scanning
- **In-place swapping** to meet space requirements
- **Optimization check** to minimize operations
- **Single pass** for optimal time complexity

The algorithm is both efficient and easy to understand, making it an excellent solution for interviews and production code.
