# 1752. Check if Array Is Sorted and Rotated

## Problem Statement

Given an array `nums`, return `true` if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return `false`.

There may be **duplicates** in the original array.

**Note:** An array `A` rotated by `x` positions results in an array `B` of the same length such that `B[i] == A[(i+x) % A.length]` for every valid index `i`.

---

## Examples

### Example 1:
```
Input: nums = [3,4,5,1,2]
Output: true
Explanation: [1,2,3,4,5] is the original sorted array.
You can rotate the array by x = 2 positions to begin on the element of value 3: [3,4,5,1,2].
```

### Example 2:
```
Input: nums = [2,1,3,4]
Output: false
Explanation: There is no sorted array once rotated that can make nums.
```

### Example 3:
```
Input: nums = [1,2,3]
Output: true
Explanation: [1,2,3] is the original sorted array.
You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.
```

---

## Constraints

* `1 <= nums.length <= 100`
* `1 <= nums[i] <= 100`

---

## Solution

### Approach: Count Breaking Points (Optimal)

**Time:** O(n) | **Space:** O(1)

```csharp
public class Solution {
    public bool Check(int[] nums) {
        int dipCount = 0;
        int n = nums.Length;
        
        for (int i = 0; i < n; i++) {
            if (nums[i] > nums[(i + 1) % n]) {
                dipCount++;
                if (dipCount > 1) return false;
            }
        }
        
        return true;
    }
}
```

---

## Algorithm Explanation

### Core Concept: The Breaking Point

A **rotated sorted array** has a special property:
- It maintains sorted order with **at most ONE breaking point**
- A breaking point occurs where `nums[i] > nums[i+1]`

**Key Insight:**
- **Sorted array (not rotated)**: 0 breaking points
- **Rotated sorted array**: Exactly 1 breaking point
- **Not sorted/rotated properly**: 2+ breaking points

### What is a "Dip" or "Breaking Point"?

A position where the sequence "breaks" - i.e., a larger number is followed by a smaller number.

```
[3, 4, 5, 1, 2]
        ↓
       5 > 1  ← Breaking point (dip)

[1, 2, 3, 4, 5]
No breaking points (sorted, not rotated)

[2, 1, 3, 4]
 ↓     ↓
2>1   4>? (wraps to 2, so 4>2)
Two breaking points → Not a rotated sorted array
```

---

## Visual Walkthrough

### Example 1: `nums = [3,4,5,1,2]` → `true`

```
Step-by-step checking:

i=0: nums[0]=3, nums[1]=4
     3 > 4? NO ✓
     dipCount = 0

i=1: nums[1]=4, nums[2]=5
     4 > 5? NO ✓
     dipCount = 0

i=2: nums[2]=5, nums[3]=1
     5 > 1? YES ✗ (Breaking point!)
     dipCount = 1

i=3: nums[3]=1, nums[4]=2
     1 > 2? NO ✓
     dipCount = 1

i=4: nums[4]=2, nums[(4+1)%5]=nums[0]=3
     2 > 3? NO ✓
     dipCount = 1

Final: dipCount = 1 → return true ✓

Visualization:
[3, 4, 5, 1, 2] → wraps around
           ↓
       Breaking point

Original sorted: [1, 2, 3, 4, 5]
Rotated by 2:    [3, 4, 5, 1, 2] ✓
```

### Example 2: `nums = [2,1,3,4]` → `false`

```
Step-by-step checking:

i=0: nums[0]=2, nums[1]=1
     2 > 1? YES ✗ (Breaking point!)
     dipCount = 1

i=1: nums[1]=1, nums[2]=3
     1 > 3? NO ✓
     dipCount = 1

i=2: nums[2]=3, nums[3]=4
     3 > 4? NO ✓
     dipCount = 1

i=3: nums[3]=4, nums[(3+1)%4]=nums[0]=2
     4 > 2? YES ✗ (Second breaking point!)
     dipCount = 2 → return false immediately ✗

Visualization:
[2, 1, 3, 4] → wraps around
    ↓        ↓
Breaking   Breaking
point 1    point 2

Two breaking points → Cannot be a rotated sorted array!
```

### Example 3: `nums = [1,2,3]` → `true`

```
Step-by-step checking:

i=0: nums[0]=1, nums[1]=2
     1 > 2? NO ✓
     dipCount = 0

i=1: nums[1]=2, nums[2]=3
     2 > 3? NO ✓
     dipCount = 0

i=2: nums[2]=3, nums[(2+1)%3]=nums[0]=1
     3 > 1? YES ✗ (Breaking point!)
     dipCount = 1

Final: dipCount = 1 → return true ✓

Visualization:
[1, 2, 3] → wraps to 1
        ↓
    Breaking point (at wrap-around)

This is sorted with 0 rotation, which is valid!
The wrap-around creates 1 breaking point (3 > 1)
```

---

## Why Check the Wrap-Around?

### The `(i + 1) % n` Trick

The modulo operation `%` makes the array **circular**:

```
Array: [3, 4, 5, 1, 2]
Index:  0  1  2  3  4

When i = 4 (last element):
(i + 1) % n = (4 + 1) % 5 = 5 % 5 = 0

So we compare nums[4] with nums[0]:
2 > 3? NO ✓

This is crucial! It checks if the end connects properly to the beginning.
```

**Why is this important?**

A rotated sorted array must be able to "wrap around" correctly:
```
[3, 4, 5, 1, 2]
           ↓   ↓
        Must connect properly!
```

If `nums[last] > nums[first]`, that's a breaking point at the wrap-around.

---

## The Logic Behind "At Most 1 Breaking Point"

### Case 1: Sorted, Not Rotated (0 breaking points)
```
[1, 2, 3, 4, 5]
No breaks in sequence
Wrap: 5 > 1 (1 break at wrap)
Result: 1 breaking point total → true ✓
```

### Case 2: Rotated Sorted Array (1 breaking point)
```
[3, 4, 5, 1, 2]
Break at: 5 > 1
Wrap: 2 < 3 (no break)
Result: 1 breaking point total → true ✓
```

### Case 3: Not Sorted Properly (2+ breaking points)
```
[2, 1, 3, 4]
Break 1: 2 > 1
Break 2: 4 > 2 (at wrap)
Result: 2 breaking points → false ✗
```

### Case 4: With Duplicates (Still works!)
```
[3, 4, 5, 5, 1, 2]
           ↓
        5 > 1 (break)
All others maintain order
Result: 1 breaking point → true ✓
```

---

## Complexity Analysis

### Time Complexity: **O(n)**
```
- Single pass through the array
- Each comparison is O(1)
- n iterations where n = array length
Total: O(n)
```

### Space Complexity: **O(1)**
```
- Only uses 2 variables: dipCount and n
- No additional data structures
- No recursion
Total: O(1)
```

**Why this is optimal:**
- Must check every element at least once → Can't do better than O(n)
- No extra space needed → Can't do better than O(1)

---

## Edge Cases Handled

### 1. Single Element
```
Input: [5]
i=0: nums[0]=5, nums[(0+1)%1]=nums[0]=5
     5 > 5? NO
     dipCount = 0
Output: true ✓

Explanation: Single element is considered sorted (0 rotation)
```

### 2. Two Elements - Sorted
```
Input: [1, 2]
i=0: 1 > 2? NO, dipCount = 0
i=1: 2 > 1? YES, dipCount = 1 (wrap-around break)
Output: true ✓
```

### 3. Two Elements - Not Sorted
```
Input: [2, 1]
i=0: 2 > 1? YES, dipCount = 1
i=1: 1 > 2? NO, dipCount = 1
Output: true ✓

Wait, this is true? Yes! [2,1] = [1,2] rotated by 1
```

### 4. All Same Elements
```
Input: [5, 5, 5, 5]
No element is strictly greater than next
dipCount = 0
Output: true ✓

Explanation: All equal = sorted (with duplicates)
```

### 5. Descending Order
```
Input: [5, 4, 3, 2, 1]
i=0: 5 > 4? YES, dipCount = 1
i=1: 4 > 3? YES, dipCount = 2 → return false
Output: false ✗

Explanation: Descending is not rotated sorted
```

### 6. Almost Sorted
```
Input: [1, 3, 2, 4, 5]
i=0: 1 > 3? NO
i=1: 3 > 2? YES, dipCount = 1
i=2: 2 > 4? NO
i=3: 4 > 5? NO
i=4: 5 > 1? YES, dipCount = 2 → return false
Output: false ✗
```

### 7. Sorted with Duplicates at Break
```
Input: [3, 4, 5, 1, 1, 2]
Breaking point at: 5 > 1
Duplicates (1, 1) maintain order
Output: true ✓
```

### 8. Large Rotation
```
Input: [2, 3, 4, 5, 1]
Breaking point at: 5 > 1
Original: [1, 2, 3, 4, 5]
Rotated by: 4 positions
Output: true ✓
```

---

## Common Mistakes to Avoid

### ❌ Mistake 1: Not Checking Wrap-Around
```csharp
// WRONG - doesn't check last to first connection
for (int i = 0; i < n - 1; i++) {  // Missing last element!
    if (nums[i] > nums[i + 1]) {
        dipCount++;
    }
}
```

**Problem:** Misses the connection from last element to first
**Fix:** Use `i < n` and `(i + 1) % n`

### ❌ Mistake 2: Using >= Instead of >
```csharp
// WRONG - fails with duplicates
if (nums[i] >= nums[(i + 1) % n]) {  // Should be >
    dipCount++;
}
```

**Problem:** Duplicates are allowed in sorted arrays!
**Example:** `[1, 2, 2, 3]` is valid, but >= would count 2==2 as a break

### ❌ Mistake 3: Returning True After Finding 1 Break
```csharp
// WRONG - early return on first break
if (nums[i] > nums[(i + 1) % n]) {
    return true;  // NO! Must count all breaks
}
```

**Problem:** Must verify there's ONLY 1 break, not just find 1

### ❌ Mistake 4: Not Using Early Return on 2nd Break
```csharp
// INEFFICIENT - continues checking after 2nd break
for (int i = 0; i < n; i++) {
    if (nums[i] > nums[(i + 1) % n]) {
        dipCount++;
    }
}
return dipCount <= 1;  // Should return false early
```

**Fix:** Add early return when `dipCount > 1` (as in our solution)

---

## Why This Solution is Elegant

### 1. Single Pass
- Only one loop through the array
- No need to find rotation point first
- No need to actually rotate or sort

### 2. Handles All Cases
- ✅ Not rotated (0 breaks at sequence, 1 at wrap)
- ✅ Rotated (1 break at rotation point)
- ✅ Duplicates (uses `>` not `>=`)
- ✅ Invalid (2+ breaks detected early)

### 3. Early Termination
```csharp
if (dipCount > 1) return false;
```
Stops immediately when second break is found - no wasted comparisons

### 4. Circular Array Handling
```csharp
(i + 1) % n
```
Elegantly handles wrap-around without special cases

---

## Alternative Approaches (Less Optimal)

### Approach 1: Find Rotation Point and Verify Both Parts
```csharp
public bool Check(int[] nums) {
    int n = nums.Length;
    int breakPoint = -1;
    
    // Find rotation point
    for (int i = 0; i < n - 1; i++) {
        if (nums[i] > nums[i + 1]) {
            if (breakPoint != -1) return false;  // Multiple breaks
            breakPoint = i;
        }
    }
    
    // Check wrap-around
    if (breakPoint != -1 && nums[n - 1] > nums[0]) {
        return false;
    }
    
    return true;
}
```
**Pros:** More intuitive logic
**Cons:** More complex, same O(n) time

### Approach 2: Rotate and Compare (Brute Force)
```csharp
public bool Check(int[] nums) {
    int n = nums.Length;
    
    for (int k = 0; k < n; k++) {
        if (IsRotatedVersion(nums, k)) return true;
    }
    
    return false;
}

private bool IsRotatedVersion(int[] nums, int k) {
    int[] sorted = (int[])nums.Clone();
    Array.Sort(sorted);
    
    for (int i = 0; i < nums.Length; i++) {
        if (nums[i] != sorted[(i + k) % nums.Length]) {
            return false;
        }
    }
    return true;
}
```
**Pros:** Very clear what it's doing
**Cons:** O(n² log n) time, O(n) space - inefficient!

---

## Interview Tips

### Opening Statement
> "I'll solve this by counting breaking points in the array. A sorted rotated array can have at most one position where a larger number is followed by a smaller number. I'll check this in a single pass with O(1) space."

### Key Points to Mention

1. **The Breaking Point Concept**
   > "In a rotated sorted array, there's at most one 'break' where the sequence resets."

2. **Circular Array Handling**
   > "I'm using modulo to treat the array as circular, checking if the last element connects properly to the first."

3. **Early Termination Optimization**
   > "As soon as I find a second breaking point, I can return false immediately."

4. **Duplicate Handling**
   > "I'm using strictly greater than (>) not (>=) because duplicates are allowed in sorted arrays."

### Follow-up Questions & Answers

**Q: What if the array could be rotated in either direction (left or right)?**
> "The solution already handles both! A left rotation by k is equivalent to a right rotation by n-k. The breaking point logic works regardless of rotation direction."

**Q: Can you find the rotation count?**
> "Yes! If the array is valid, the rotation count is the index of the breaking point. For `[3,4,5,1,2]`, the break is at index 2, so it's rotated by 2 positions. If no break in the sequence, it's rotated by n (full rotation = 0 effective)."

**Q: How would you handle a very large array?**
> "The O(n) time is already optimal. For massive arrays, we could potentially use parallel processing to check sections simultaneously, but the serial version is already very efficient."

**Q: What if we need to return the original sorted array?**
> "I would first verify it's valid with this check. Then find the breaking point and construct the result by concatenating `nums[breakPoint+1:] + nums[:breakPoint+1]`."

---

## Proof of Correctness

### Why "At Most 1 Break" is Sufficient

**Theorem:** An array is a rotated sorted array if and only if it has at most one breaking point (including wrap-around).

**Proof:**

**Part 1: If sorted and rotated → at most 1 break**
- A sorted array: `[1, 2, 3, 4, 5]` has 0 breaks in sequence
- Rotating it: `[3, 4, 5, 1, 2]` creates exactly 1 break at rotation point
- The wrap-around is smooth if rotated, or becomes a break if not rotated

**Part 2: If at most 1 break → must be sorted and rotated**
- 0 breaks in sequence means fully sorted (1 break at wrap due to circular check)
- 1 break in sequence means sorted but shifted
- 2+ breaks means elements are out of order and can't form a rotation

**Therefore:** Counting breaks ≤ 1 perfectly identifies rotated sorted arrays. ∎

---

## Related LeetCode Problems

| Problem | Difficulty | Similarity |
|---------|-----------|------------|
| **1752. Check if Array Is Sorted and Rotated** | Easy | This problem |
| 33. Search in Rotated Sorted Array | Medium | Uses rotated sorted property |
| 81. Search in Rotated Sorted Array II | Medium | With duplicates |
| 153. Find Minimum in Rotated Sorted Array | Medium | Find rotation point |
| 154. Find Minimum in Rotated Sorted Array II | Hard | With duplicates |
| 189. Rotate Array | Medium | Actual rotation operation |

---

## Practice Variations

1. **Find Rotation Count**: Return the number of rotations (index of break)
2. **Restore Original**: Return the original sorted array
3. **Multiple Rotations**: Check if array is rotated k times
4. **Rotated Descending**: Check if originally in descending order
5. **2D Arra**y: Check if any row is a rotated sorted array
