Code and explination
[ExcludeFromCodeCoverage]
 public ref struct Utf8JsonStreamReaderHelper
 {
  private readonly Stream _stream;
  // note: buffers will often be bigger than this - do not ever use this number for calculations.
  private readonly int _bufferSize;

  private SequenceSegment? _firstSegment;
  private int _firstSegmentStartIndex;
  private SequenceSegment? _lastSegment;
  private int _lastSegmentEndIndex;

  private Utf8JsonReader _jsonReader;
  private bool _keepBuffers;
  private bool _isFinalBlock;

  public Utf8JsonStreamReaderHelper(Stream stream, int bufferSize)
  {
   _stream = stream;
   _bufferSize = bufferSize;

   _firstSegment = null;
   _firstSegmentStartIndex = 0;
   _lastSegment = null;
   _lastSegmentEndIndex = -1;

   _jsonReader = default;
   _keepBuffers = false;
   _isFinalBlock = false;
  }


  public bool Read()
  {
   // read could be unsuccessful due to insufficient bufer size, retrying in loop with additional buffer segments
   while (!_jsonReader.Read())
   {
    if (_isFinalBlock)
    {
     return false;
    }

    MoveNext();
   }
   return true;
  }

  private void MoveNext()
  {
   _firstSegmentStartIndex += (int)_jsonReader.BytesConsumed;

   // release previous segments if possible
   while (_firstSegmentStartIndex > 0 && _firstSegment?.Memory.Length <= _firstSegmentStartIndex)
   {
    var currFirstSegment = _firstSegment;
    _firstSegmentStartIndex -= _firstSegment.Memory.Length;
    _firstSegment = (SequenceSegment?)_firstSegment.Next;
    if (!_keepBuffers)
    {
     currFirstSegment.Dispose();
    }
   }

   // create new segment
   var newSegment = new SequenceSegment(_bufferSize, _lastSegment);
   _lastSegment?.SetNext(newSegment);
   _lastSegment = newSegment;

   if (_firstSegment == null)
   {
    _firstSegment = newSegment;
    _firstSegmentStartIndex = 0;
   }

   // read data from stream
   _lastSegmentEndIndex = 0;
   int bytesRead;
   do
   {
    bytesRead = _stream.Read(newSegment.Buffer.Memory.Span.Slice(_lastSegmentEndIndex));
    _lastSegmentEndIndex += bytesRead;
   } while (bytesRead > 0 && _lastSegmentEndIndex < newSegment.Buffer.Memory.Length);

   _isFinalBlock = _lastSegmentEndIndex < newSegment.Buffer.Memory.Length;
   var data = new ReadOnlySequence<byte>(_firstSegment, _firstSegmentStartIndex, _lastSegment, _lastSegmentEndIndex);
   _jsonReader = new Utf8JsonReader(data, _isFinalBlock, _jsonReader.CurrentState);
  }


  private void DeserialisePost()
  {
   // release memory if possible
   var firstSegment = _firstSegment;
   var firstSegmentStartIndex = _firstSegmentStartIndex + (int)_jsonReader.BytesConsumed;

   while (firstSegment?.Memory.Length < firstSegmentStartIndex)
   {
    firstSegmentStartIndex -= firstSegment.Memory.Length;
    firstSegment.Dispose();
    firstSegment = (SequenceSegment?)firstSegment.Next;
   }

   if (firstSegment != _firstSegment)
   {
    _firstSegment = firstSegment;
    _firstSegmentStartIndex = firstSegmentStartIndex;
    var data = new ReadOnlySequence<byte>(_firstSegment!, _firstSegmentStartIndex, _lastSegment!,
      _lastSegmentEndIndex);
    _jsonReader =
      new Utf8JsonReader(data, _isFinalBlock, _jsonReader.CurrentState);
   }
  }

  private long DeserialisePre(out SequenceSegment? firstSegment, out int firstSegmentStartIndex)
  {
   // JsonSerializer.Deserialize can read only a single object. We have to extract
   // object to be deserialized into separate Utf8JsonReader. This incurs one additional
   // pass through data (but data is only passed, not parsed).
   var tokenStartIndex = _jsonReader.TokenStartIndex;
   firstSegment = _firstSegment;
   firstSegmentStartIndex = _firstSegmentStartIndex;

   // loop through data until end of object is found
   _keepBuffers = true;
   int depth = 0;

   if (TokenType == JsonTokenType.StartObject || TokenType == JsonTokenType.StartArray)
    depth++;

   while (depth > 0 && Read())
   {
    if (TokenType == JsonTokenType.StartObject || TokenType == JsonTokenType.StartArray)
     depth++;
    else if (TokenType == JsonTokenType.EndObject || TokenType == JsonTokenType.EndArray)
     depth--;
   }

   _keepBuffers = false;
   return tokenStartIndex;
  }

  public T? Deserialise<T>(JsonSerializerOptions? options = null)
  {
   var tokenStartIndex = DeserialisePre(out var firstSegment, out var firstSegmentStartIndex);


   var seq = new ReadOnlySequence<byte>(firstSegment!, firstSegmentStartIndex, _lastSegment!,
     _lastSegmentEndIndex).Slice(tokenStartIndex, _jsonReader.Position);
   var newJsonReader = new Utf8JsonReader(seq, true, default);

   // deserialize value
   var result = JsonSerializer.Deserialize<T>(ref newJsonReader, options);

   DeserialisePost();
   return result;
  }

  public void Dispose() 
  { 
   _lastSegment?.Dispose(); 
   _stream?.Dispose();
   _firstSegment?.Dispose();
  }
  public JsonTokenType TokenType => _jsonReader.TokenType; 
  public string? GetString() => _jsonReader.GetString();
  
  private sealed class SequenceSegment : ReadOnlySequenceSegment<byte>, IDisposable
  {
   internal IMemoryOwner<byte> Buffer { get; }
   internal SequenceSegment? Previous { get; set; }
   private bool _disposed;

   public SequenceSegment(int size, SequenceSegment? previous)
   {
    Buffer = MemoryPool<byte>.Shared.Rent(size);
    Previous = previous;

    Memory = Buffer.Memory;
    RunningIndex = previous?.RunningIndex + previous?.Memory.Length ?? 0;
   }

   public void SetNext(SequenceSegment next) => Next = next;

   public void Dispose()
   {
    // Dispose of this and all previous segments iteratively, not recursively.
    for (var segment = this; segment != null; segment = segment.Previous)
    {
     if (segment._disposed)
      continue;

     segment._disposed = true;
     segment.Buffer.Dispose();
    }
   }
  }
 }


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                             Input JSON Stream                              â”‚
â”‚      {"id":1,"name":"Alice"}{"id":2,"name":"Bob"} ...                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚  var bytesRead = stream.Read(buffer);    â”‚ â† [Line 1]            â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ SegmentA       â”‚ SegmentB       â”‚ SegmentC       â”‚ â† [Line 2-4]        â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†‘               â†‘                â†‘
        Start           Middle             End
           â†“               â†“                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   var sequence = new ReadOnlySequence<byte>(segmentA, 0, segmentC, length);â”‚ â† [Line 5] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ var reader = new Utf8JsonReader(sequence, isFinalBlock, state); â”‚ â† [Line 6] â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ var obj = JsonSerializer.Deserialize<MyClass>(ref reader);  â”‚ â† [Line 7] â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
         âœ… Object Result â†’ new MyClass { Id = 1, Name = "Alice" }   â† [Line 8]


Utf8JsonStreamReaderHelper
A low-level helper for deserializing UTF-8 JSON objects from a stream, using memory segmentation and Utf8JsonReader. Supports buffered streaming, partial reads, and memory pooling.
ğŸ§± Fields
csharp
private readonly Stream _stream;
private readonly int _bufferSize;
_stream: Source of JSON data (file, network, etc.)

_bufferSize: Size for each memory segment (but actual buffers may differâ€”donâ€™t rely on this for limits)

csharp
private SequenceSegment? _firstSegment;
private int _firstSegmentStartIndex;
private SequenceSegment? _lastSegment;
private int _lastSegmentEndIndex;
Track segment boundaries for current ReadOnlySequence<byte> window

csharp
private Utf8JsonReader _jsonReader;
private bool _keepBuffers;
private bool _isFinalBlock;
_jsonReader: Core parser

_keepBuffers: Keeps segments in memory for multi-pass parsing

_isFinalBlock: Signals end-of-stream when fewer bytes than buffer size are read

ğŸ— Constructor
csharp
public Utf8JsonStreamReaderHelper(Stream stream, int bufferSize)
Initializes the parser and segment tracking state

StartIndex and EndIndex mark logical read window in segmented buffer

ğŸ” Read()
csharp
public bool Read()
Core loop to advance Utf8JsonReader

If parsing fails due to incomplete data, it calls MoveNext() to fetch more from stream

Stops if _isFinalBlock is reached

â© MoveNext()
csharp
private void MoveNext()
Advances by reading more data from _stream into a new segment

Disposes fully consumed segments unless _keepBuffers is true

Updates _jsonReader to point to newly extended ReadOnlySequence<byte>

ğŸ§¼ DeserialisePost()
csharp
private void DeserialisePost()
Cleans up memory after successful deserialization

Releases used segments and updates reader position accordingly

ğŸ” DeserialisePre()
csharp
private long DeserialisePre(out SequenceSegment? firstSegment, out int firstSegmentStartIndex)
Prepares a slice of JSON tokens for object-level deserialization

Walks through token stream using depth tracking to find end of the object

Keeps buffers until full object is available

ğŸ“¤ Deserialise<T>()
csharp
public T? Deserialise<T>(JsonSerializerOptions? options = null)
Combines DeserialisePre() and DeserialisePost() with actual deserialization

Creates a new Utf8JsonReader over just the extracted object range

Returns final C# object

ğŸ§¹ Dispose()
csharp
public void Dispose()
Frees up memory (segments + stream) to avoid leaks

Cleans segments in reverse using Previous pointers

ğŸ§¾ Additional Helpers
csharp
public JsonTokenType TokenType => _jsonReader.TokenType;
public string? GetString() => _jsonReader.GetString();
Allows access to the current token type and string value if applicable

ğŸ§© SequenceSegment Class
csharp
private sealed class SequenceSegment : ReadOnlySequenceSegment<byte>, IDisposable
Represents a chunk of memory allocated from the shared MemoryPool

Linked list via Previous and Next

Implements custom Dispose() to clean up entire chain iteratively

ğŸ”„ Memory Layout
text
[ Segment A ] â†’ [ Segment B ] â†’ [ Segment C ]
      â†‘             â†‘              â†‘
  Start Index   Mid Parsing    End of Object
Each segment is a buffer slice, linked to form a ReadOnlySequence<byte>. Parsing advances byte-by-byte across segment boundaries.

Design Notes
âœ… Buffers rented from MemoryPool<byte> for high-efficiency reuse

ğŸ”„ Segments linked via Next and Previous pointers

ğŸ§¹ Memory disposal is iterative to avoid stack overflow from recursion

ğŸ“ Depth tracking (DeserialisePre) ensures complete objects are sliced before deserializing

ğŸ“‚ Project Structure
Component	Purpose
Utf8JsonStreamReaderHelper.cs	Core deserializer and stream parser
SequenceSegment	Internal segment wrapper for pooled memory blocks
Deserialise<T>()	Extracts and deserializes JSON objects
DeserialisePre()	Depth scans to find object boundary
DeserialisePost()	Cleans up consumed segments
