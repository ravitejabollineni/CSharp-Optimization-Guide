# 189. Rotate Array by K Steps

## Problem Description

Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative.

### Examples

**Example 1:**

```
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]

Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
```

**Example 2:**

```
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]

Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
```


### Constraints

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`


### Follow-up Questions

Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.
Could you do it in-place with O(1) extra space?

## Solution

### Approach: Three Reversals Algorithm

The optimal solution uses a clever three-step reversal approach that achieves **O(1) space complexity** and **O(n) time complexity**.

**Algorithm Steps:**

1. **Reverse the entire array**
2. **Reverse the first k elements**
3. **Reverse the remaining n-k elements**

### Implementation (C\#)

```csharp
public class Solution 
{
    public void Rotate(int[] nums, int k) 
    {
        int n = nums.Length;
        k = k % n;  // Handle cases where k > array length
        
        ReverseArray(nums, 0, n - 1);    // Step 1: Reverse entire array
        ReverseArray(nums, 0, k - 1);    // Step 2: Reverse first k elements
        ReverseArray(nums, k, n - 1);    // Step 3: Reverse remaining elements
    }
    
    public void ReverseArray(int[] nums, int start, int end)
    {
        while (start < end)
        {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;        
            start++;
            end--;
        }
    }
}
```


### How It Works

**Example walkthrough with `nums = [1][2][3][4][5][6][7]`, `k = 3`:**

1. **Initial array:** `[1][2][3][4][5][6]`
2. **After reversing entire array:** `[7][6][5][4][3][2]`
3. **After reversing first 3 elements:** `[5][6][7][4][3][2]`
4. **After reversing remaining elements:** `[5][6][7][1][2][3]`

**Result:** `[5][6][7][1][2][3]` ✓

### Why This Works

The key insight is that rotating an array to the right by `k` positions is equivalent to:

- Moving the last `k` elements to the front
- Moving the first `n-k` elements to the back

The three reversals achieve this transformation elegantly:

1. First reversal puts elements in reverse order
2. Second reversal correctly positions the first `k` elements (originally the last `k`)
3. Third reversal correctly positions the remaining elements

### Complexity Analysis

- **Time Complexity:** O(n) - We traverse the array three times
- **Space Complexity:** O(1) - Only using constant extra space for variables


### Key Optimizations

1. **Modulo Operation:** `k = k % n` handles cases where `k` is larger than the array length
2. **In-place Rotation:** No additional arrays needed, satisfying the O(1) space requirement
3. **Edge Case Handling:** Works correctly when `k = 0` or `k >= n`

### Alternative Solutions

#### 1. Brute Force (Time: O(n×k), Space: O(1))

```csharp
// Rotate one position k times
for (int i = 0; i < k; i++) {
    int last = nums[nums.Length - 1];
    for (int j = nums.Length - 1; j > 0; j--) {
        nums[j] = nums[j - 1];
    }
    nums[0] = last;
}
```


#### 2. Using Extra Array (Time: O(n), Space: O(n))

```csharp
int[] result = new int[nums.Length];
for (int i = 0; i < nums.Length; i++) {
    result[(i + k) % nums.Length] = nums[i];
}
// Copy back to original array
```


#### 3. Cyclic Replacements (Time: O(n), Space: O(1))

```csharp
// Move elements directly to their final positions
// More complex implementation but also O(1) space
```


### Test Cases

```csharp
// Test the solution
var solution = new Solution();

// Test Case 1
int[] nums1 = {1,2,3,4,5,6,7};
solution.Rotate(nums1, 3);
Console.WriteLine($"[{string.Join(",", nums1)}]"); // [5,6,7,1,2,3,4]

// Test Case 2
int[] nums2 = {-1,-100,3,99};
solution.Rotate(nums2, 2);
Console.WriteLine($"[{string.Join(",", nums2)}]"); // [3,99,-1,-100]

// Edge Case: k > array length
int[] nums3 = {1,2};
solution.Rotate(nums3, 3); // Same as k = 1 due to modulo
Console.WriteLine($"[{string.Join(",", nums3)}]"); // [2,1]
```

This solution elegantly solves the array rotation problem with optimal space complexity while maintaining excellent time performance, making it ideal for scenarios with memory constraints or large datasets.

