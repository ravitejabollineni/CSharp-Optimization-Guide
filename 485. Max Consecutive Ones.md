# 485. Max Consecutive Ones

## Problem Statement

Given a binary array `nums`, return the maximum number of consecutive `1`'s in the array.

---

## Examples

### Example 1:
```
Input: nums = [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s. 
The maximum number of consecutive 1s is 3.
```

### Example 2:
```
Input: nums = [1,0,1,1,0,1]
Output: 2
```

---

## Constraints

* `1 <= nums.length <= 10^5`
* `nums[i]` is either `0` or `1`

---

## Solution

### Approach: Single Pass with Counter

This solution uses a **single-pass counter** approach with elegant logic.

```csharp
public class Solution {
    public int FindMaxConsecutiveOnes(int[] nums) {
        int count = 0;
        int maxNumber = 0;
        for(int i = 0; i < nums.Length; i++)
        {
           count = nums[i] == 1 ? count + 1 : 0;
           maxNumber = Math.Max(maxNumber, count);
        }
        return maxNumber;
    }
}
```

---

## Algorithm Explanation

### Core Concept

The algorithm maintains two variables:
- **`count`**: Tracks the current streak of consecutive 1's
- **`maxNumber`**: Stores the maximum streak found so far

### Step-by-Step Process

1. **Initialize** both `count` and `maxNumber` to 0
2. **Iterate** through each element in the array
3. **For each element**:
   - If it's `1`: Increment `count` by 1
   - If it's `0`: Reset `count` to 0
4. **Update** `maxNumber` after each iteration
5. **Return** `maxNumber` as the final result

### The Ternary Operator Magic

```csharp
count = nums[i] == 1 ? count + 1 : 0;
```

This single line elegantly handles both cases:
- **If `nums[i] == 1`**: Continue the streak (`count + 1`)
- **If `nums[i] == 0`**: Break the streak (reset to `0`)

---

## Visual Walkthrough

Let's trace through Example 1: `nums = [1,1,0,1,1,1]`

```
Initial State:
count = 0, maxNumber = 0

Index 0: nums[0] = 1
├─ count = 1 ? 0+1 : 0 = 1
├─ maxNumber = max(0, 1) = 1
└─ Array: [1, 1, 0, 1, 1, 1]
           ↑
         count=1, max=1

Index 1: nums[1] = 1
├─ count = 1 ? 1+1 : 0 = 2
├─ maxNumber = max(1, 2) = 2
└─ Array: [1, 1, 0, 1, 1, 1]
              ↑
         count=2, max=2

Index 2: nums[2] = 0
├─ count = 1 ? 2+1 : 0 = 0  ← Reset!
├─ maxNumber = max(2, 0) = 2
└─ Array: [1, 1, 0, 1, 1, 1]
                 ↑
         count=0, max=2

Index 3: nums[3] = 1
├─ count = 1 ? 0+1 : 0 = 1
├─ maxNumber = max(2, 1) = 2
└─ Array: [1, 1, 0, 1, 1, 1]
                    ↑
         count=1, max=2

Index 4: nums[4] = 1
├─ count = 1 ? 1+1 : 0 = 2
├─ maxNumber = max(2, 2) = 2
└─ Array: [1, 1, 0, 1, 1, 1]
                       ↑
         count=2, max=2

Index 5: nums[5] = 1
├─ count = 1 ? 2+1 : 0 = 3
├─ maxNumber = max(2, 3) = 3  ← New maximum!
└─ Array: [1, 1, 0, 1, 1, 1]
                          ↑
         count=3, max=3

Return: 3 ✓
```

---

## Key Insights

### 1. Why Update `maxNumber` Every Iteration?

```csharp
maxNumber = Math.Max(maxNumber, count);
```

This is done **after every element** (not just when we find a 1) because:
- ✅ Ensures we don't miss the maximum if the last elements are 1's
- ✅ Handles edge case where entire array is 1's
- ✅ Simplifies logic - no need for special end-of-array handling

### 2. The Power of Ternary Operator

Instead of verbose if-else:
```csharp
// Verbose approach
if (nums[i] == 1) {
    count++;
} else {
    count = 0;
}
```

We use concise ternary:
```csharp
// Elegant approach
count = nums[i] == 1 ? count + 1 : 0;
```

Benefits:
- ✅ More readable once you understand it
- ✅ Less code (fewer lines = fewer bugs)
- ✅ Clearer intent

### 3. Why Not Check for Zero Explicitly?

Since the array is **binary** (only 0 or 1):
- If `nums[i] != 1`, it **must be 0**
- No need to check both conditions
- Makes code cleaner and more efficient

---

## Complexity Analysis

### Time Complexity: **O(n)**
- Single pass through the array
- Each element visited exactly once
- `n` = length of the array

**Breakdown:**
- Loop: O(n)
- Ternary operation: O(1)
- Math.Max: O(1)
- **Total: O(n)**

### Space Complexity: **O(1)**
- Only uses two integer variables (`count` and `maxNumber`)
- No additional data structures
- Space usage independent of input size

---

## Why This Solution is Optimal

### Advantages

1. ✅ **Optimal Time**: Cannot do better than O(n) - must check every element
2. ✅ **Minimal Space**: O(1) is the best possible
3. ✅ **Single Pass**: No need to iterate multiple times
4. ✅ **Clean Code**: Concise and readable with ternary operator
5. ✅ **No Edge Case Issues**: Handles all scenarios naturally

### Comparison with Alternative Approaches

| Approach | Time | Space | Code Complexity | Readability |
|----------|------|-------|-----------------|-------------|
| **Ternary Counter (This solution)** | **O(n)** | **O(1)** | **Simple** | **High** |
| If-Else Counter | O(n) | O(1) | Simple | High |
| Two-Pass (Count then Max) | O(2n) | O(k) | Medium | Medium |
| String Split | O(n) | O(n) | Simple | Medium |
| Recursion | O(n) | O(n) | Complex | Low |

---

## Edge Cases Handled

### 1. All Ones
```
Input: [1, 1, 1, 1]
Output: 4
✓ count keeps incrementing, maxNumber updated at end
```

### 2. All Zeros
```
Input: [0, 0, 0]
Output: 0
✓ count stays 0, maxNumber stays 0
```

### 3. Single Element (One)
```
Input: [1]
Output: 1
✓ count = 1, maxNumber = 1
```

### 4. Single Element (Zero)
```
Input: [0]
Output: 0
✓ count = 0, maxNumber = 0
```

### 5. Alternating
```
Input: [1, 0, 1, 0, 1]
Output: 1
✓ Each 1 resets count to 1, max stays 1
```

### 6. Ones at Beginning
```
Input: [1, 1, 1, 0, 0]
Output: 3
✓ maxNumber captured before zeros
```

### 7. Ones at End
```
Input: [0, 0, 1, 1, 1]
Output: 3
✓ Updated on last iteration (this is why we update every time!)
```

### 8. Multiple Streaks
```
Input: [1, 1, 0, 1, 1, 1, 0, 1, 1]
Output: 3
✓ Correctly identifies longest among multiple streaks
```

---

## Common Mistakes to Avoid

### ❌ Mistake 1: Not Updating `maxNumber` Every Iteration
```csharp
// WRONG - misses max at array end
if (nums[i] == 1) {
    count++;
    maxNumber = Math.Max(maxNumber, count);
} else {
    count = 0;
}
```

**Problem:** If array ends with 1's, max might not be updated!

**Fix:** Update `maxNumber` outside the condition (like our solution)

### ❌ Mistake 2: Checking Both 0 and 1
```csharp
// WRONG - unnecessary check
if (nums[i] == 1) {
    count++;
} else if (nums[i] == 0) {  // Redundant!
    count = 0;
}
```

**Problem:** Binary array means if not 1, it's 0!

**Fix:** Use simple `else` or
